---
title: High Availability & Global Replication
objective: Set up a Postgres cluster, configure replicas, perform failovers, and learn what tradeoffs should be considered for a global Postgres deployment.
layout: framework_docs
order: 1
redirect_from: /docs/postgres/high-availability-and-global-replication/
---

Fly Postgres uses [repmgr](https://www.repmgr.org/) to manage clusters of 3+ Postgres servers. Older Fly Postgres apps use [stolon](https://github.com/sorintlab/stolon) for leader election and streaming replication between 2+ Postgres servers. Newer apps that use repmgr, and require at least 3 Postgres servers for quorum, use a postgres-flex image. Run `fly status --app <app name>` or `fly image show --app <app name>` to view the image name and version.

## Adding replicas

The easiest way to add additional replicas is with the `fly machine clone` command:

```cmd
fly machine clone <machine ID> --region <region> --app <app name>
```

For example:

```cmd
fly machine clone 148e306c77e089 --region lax --app my-app-name
```
```output
Cloning machine 148e306c77e089 into region lax
Volume 'pg_data' will start empty
Provisioning a new machine with image registry-1.docker.io/flyio/postgres-flex:15...
  Machine 17814e3b990389 has been created...
  Waiting for machine 17814e3b990389 to start...
  Waiting for 17814e3b990389 to become healthy (started, 3/3)
Machine has been successfully cloned!
```

This will clone the spec from the source Machine and use it to create the new replica in the specified region.


## Performing a failover

To perform a failover, you need to have 3 or more servers. Run the following command:

```cmd
fly postgres failover --app <app name>
```

For example:
```cmd
fly postgres failover --app my-app-name
```
```output
Performing a failover
Connecting to fdaa:2:45b:a7b:174:f553:db80:2... complete
Stopping current leader...  17811073b07918
Starting new leader
Promoting new leader...  4d891247b0d698
Connecting to fdaa:2:45b:a7b:174:f553:db80:2... complete
NOTICE: promoting standby to primary
DETAIL: promoting server "fdaa:2:45b:a7b:174:f553:db80:2" (ID: 665772506) using pg_promote()
NOTICE: waiting up to 60 seconds (parameter "promote_check_timeout") for promotion to complete
NOTICE: STANDBY PROMOTE successful
DETAIL: server "fdaa:2:45b:a7b:174:f553:db80:2" (ID: 665772506) was successfully promoted to primary
NOTICE: executing STANDBY FOLLOW on 1 of 1 siblings
INFO: STANDBY FOLLOW successfully executed on all reachable sibling nodes
Waiting 30 seconds for the old leader to stop...
Restarting old leader... 17811073b07918
Waiting for leadership to swap to 4d891247b0d698...
  Waiting for 17811073b07918 to become healthy (started, 3/3)
  Waiting for 4d891247b0d698 to become healthy (started, 3/3)
  Waiting for 3d8d9e15c9de58 to become healthy (started, 3/3)
Failover complete
```

<div class="note icon">
**Note:** Only healthy servers residing in your primary region will be considered for leadership.
</div>

## Performing a regional failover

There may be situations where you want to move leadership into a completely new region.

If you haven't already pulled down your `fly.toml` configuration file, you can do so by running:

```
fly config save --app <app-name>
```

Open the `fly.toml` file and set the [`primary_region`](https://fly.io/docs/reference/configuration/#primary-region) and the `PRIMARY_REGION` environment variable to your target region. For example, to move leadership into the `lax` region:

```toml
primary_region = "lax"

[env]
PRIMARY_REGION = "lax"
```

Before deploying this change, identify which Postgres version you are currently running. Use `fly image show` to get the image and version info.

For example:

```cmd
fly image show
```
```output
Image Details
MACHINE ID    	REGISTRY            	REPOSITORY         	TAG 	VERSION	DIGEST          LABELS
4d891247b0d698	registry-1.docker.io	flyio/postgres-flex	15.3	v0.0.46	sha256:44b6...	fly.app_role=postgres_clusterfly.pg-manager=repmgr...
17811073b07918	registry-1.docker.io	flyio/postgres-flex	15.3	v0.0.46	sha256:44b6...	fly.app_role=postgres_clusterfly.pg-manager=repmgr...
3d8d9e15c9de58	registry-1.docker.io	flyio/postgres-flex	15.3	v0.0.46	sha256:44b6...	fly.pg-manager=repmgrfly.pg-version=15.3-1.pgdg120...
```

Take note of the version specified in the `Tag` column, you'll use it for the next command.

<div class="warning icon">
**Warning:** This deploy process will result in a small amount of downtime. Once the primary region change has been deployed, your cluster will become read-only until the failover process completes.
</div>

```cmd
fly deploy . --image flyio/postgres-flex:<tag> --strategy=immediate
```

Once the deploy process has completed, you can transfer leadership into the new region. 

<div class="important icon">
Ensure the new region has at least three healthy servers to maintain quorum (see above on how to [add more replicas](#adding-replicas)).
</div>

```cmd
fly pg failover
```
```output
Performing a failover
  Waiting for e784927ad23583 to become healthy (started, 3/3)
  Waiting for 148e306c77e089 to become healthy (started, 3/3)
Failover complete
```

That's it! You should now run `fly status` to verify your changes.

## Connecting to read replicas

The generated connection string uses port `5432` to connect to PostgreSQL. This port always forwards you to a writable instance. Port `5433` is direct to the PostgreSQL member, and used to connect to read replicas directly.

You can use the proxy port (`5432`) to connect from every region, but it will be quite slow. Especially because we put our PostgreSQL cluster in Santiago. Connecting to "local" replicas is much quicker, but does take some app logic.

The basic logic to connect is:

1. Set a `PRIMARY_REGION` environment variable on your app, `scl` for our `chaos-postgres` cluster.
2. Check the `FLY_REGION` environment variable at connect time, use `DATABASE_URL` as is when `FLY_REGION=scl`
3. Modify the `DATABASE_URL` when running in other regions:
   1. Change the port to `5433`

This is what it looks like in Ruby:

```ruby
class Fly
  def self.database_url
    primary = ENV["PRIMARY_REGION"]
    current = ENV["FLY_REGION"]
    db_url = ENV["DATABASE_URL"]

    if primary.blank? || current.blank? || primary == current
      return db_url
    end

    u = URI.parse(db_url)
    u.port = 5433

    return u.to_s
  end
end
```

Running this in `scl` will use the built-in `DATABASE_URL` and connect to port `5432`:

```
postgres://<user>:<password>@top1.nearest.of.chaos-postgres.internal:5432/rails_on_fly?sslmode=disable
```

In the other regions, the app will connect to port `5433`:

```
postgres://<user>:<password>@top1.nearest.of.chaos-postgres.internal:5433/rails_on_fly?sslmode=disable
```

## Detecting write requests

### Catch read-only errors

PostgreSQL conveniently sends a "read only transaction" error when you attempt to write to a read replica. All you need to do to detect write requests is catch this error.

### Replay the request

Once caught, just send a `fly-replay` header specifying the primary region. For `chaos-postgres`, send `fly-replay: region=scl`, and we'll take care of the rest.

If you're working in Rails, just add this to your `ApplicationController`:

```ruby
class ApplicationController < ActionController::Base
  rescue_from ActiveRecord::StatementInvalid do |e|
    if e.cause.is_a?(PG::ReadOnlySqlTransaction)
      r = ENV["PRIMARY_REGION"]
      response.headers["fly-replay"] = "region=#{r}"
      Rails.logger.info "Replaying request in #{r}"
      render plain: "retry in region #{r}", status: 409
    else
      raise e
    end
  end
end
```

## Library support

We would like to build libraries to make this seamless for most application frameworks and runtimes. If you have a particular app you'd like to distribute with PostgreSQL, [post in our community forums](https://community.fly.io/t/multi-region-database-guide/1600) and we'll write some code for you.

## Consistency model

This is a fairly typical read replica model. Read replicas are usually eventually consistent, and can fall behind the leader. Running read replicas across the world can exacerbate this effect and make read replicas stale more frequently.

### Request with writes

Requests to the primary region are strongly consistent. When you use the replay header to target a particular region, the entire request runs against the leader database. Your application will behave like you expect.

### Read only requests

Most apps accept a `POST` or `PUT`, do a bunch of writes, and then redirect the user to a `GET` request. In most cases, the database will replicate the changes before the user makes the second request. But not always!

Most read heavy applications aren't especially sensitive to stale data on subsequent requests. A lagging read replica might result in an out of date view for users, but this might be reasonable for your use case.

If your app is sensitive to this (meaning, you never, under any circumstances want to show users stale data), you should be careful using read replicas.

### Managing eventual consistency

For apps that are sensitive to consistency issues, you can add a counter or timestamp to user sessions that indicates what "version" of the database a particular user is expecting. When the user makes a request and the session's data version differs from the replica, you can use the same `fly-replay` header to redirect their request to the primary region – and then you'll know it's not stale.

In theory, you _could_ run PostgreSQL with synchronous replication and block until replicas receive writes. This probably won't work well for far flung read replicas.

## This is wrong for some apps

We built this set of features for read heavy apps that are primary HTTP request based. That is, most requests only perform reads and only some requests include writes.

### Write-heavy workloads

If you write to the database on every request, this will not work for you. You will need to make some architectural changes to run a write-heavy app in multiple regions.

Some apps write background info like metrics or audit logs on every request, but are otherwise read heavy. If you're running an application like this, you should consider using something like [nats.io](https://nats.io) to send information to your primary region asynchronously.

Truly write-heavy apps require latency aware data partitioning, either at the app level or in a database engine. There are lots of interesting new databases that have features for this, try them out!

### Long lived connections

If your app makes heavy use of long lived connections with interpolated writes, like websockets, this will not work for you. This technique is specific to HTTP request/response based apps that bundle writes up into specific requests.
