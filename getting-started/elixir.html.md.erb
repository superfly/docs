---
title: "Deploy an Elixir Phoenix Application"
layout: docs
sitemap: false
nav: firecracker
---

<%= partial "partials/intro", locals: { runtime: "Elixir Phoenix", database: true } %>

We'll be using the standard web application generated by the Elixir [Phoenix Framework](https://www.phoenixframework.org/). This guide assumes you're working with **Phoenix 1.6.3** or later which include a code generator to simplify deployment.

## Generate the app and deploy with Postgres

If you just want to see how Fly deployment works, follow these steps.

First, [install flyctl](https://fly.io/docs/getting-started/installing-flyctl/), your Fly app command center, and [sign up to Fly](http://localhost:4567/docs/getting-started/log-in-to-fly/#first-time-or-no-fly-account-sign-up-for-fly) if you haven't already.

Now let's generate a shiny, new Phoenix app.

```cmd
mix phx.new hello_elixir
```
```output
* creating fresh/config/config.exs
* creating fresh/config/dev.exs
* creating fresh/config/prod.exs
...
```
<%= partial "partials/launch_with_postgres", locals: { detected: "Phoenix", app_name: "hello_elixir" } %>

## _Getting an IEx Shell into a Running Node_

Elixir supports getting a IEx shell into a running production node. How cool is that? This requires a bit more setup.

`rel/env.sh.eex` is run when your app boots. Create or update it with the following contents, and run `fly deploy`.

```
ip=$(grep fly-local-6pn /etc/hosts | cut -f 1)
export RELEASE_DISTRIBUTION=name
export RELEASE_NODE=$FLY_APP_NAME@$ip
```

The `flyctl` command will always refer to this file in the current directory if it exists, specifically for the `app` name/value at the start. That name is used to identify the application to the Fly platform. The rest of the file contains settings to be applied to the application when it deploys.

We'll have more details about these properties as we progress, but for now, it's enough to say that they mostly configure which ports the application will be visible on.

## _Customizing `fly.toml`_

Elixir applications need a little customization to the generated `fly.toml` file.

```toml
app = "fly-elixir"

kill_signal = "SIGTERM"
kill_timeout = 5
processes = []

[deploy]
  release_command = "/app/entry eval HelloElixir.Release.migrate"

[env]

[experimental]
  allowed_public_ports = []
  auto_rollback = true

[[services]]
  http_checks = []
  internal_port = 4000
  processes = ["app"]
  protocol = "tcp"
  script_checks = []

  [services.concurrency]
    hard_limit = 25
    soft_limit = 20
    type = "connections"

  [[services.ports]]
    handlers = ["http"]
    port = 80

  [[services.ports]]
    handlers = ["tls", "http"]
    port = 443

  [[services.tcp_checks]]
    grace_period = "30s"  # allow some time for startup
    interval = "15s"
    restart_limit = 0
    timeout = "2s"
```

There are two important changes here:

- We added the `[deploy]` setting. This tells Fly that on a new deploy, **run our database migrations**. The Dockerfile we're using creates a symlink to your app name called `entry`. This uses that symlink run the migrate command.
- The `kill_signal` is set to `SIGTERM`. An Elixir node does a clean shutdown when it receives a `SIGTERM` from the OS.
- The `internal_port` is set to 4000 for our Elixir application. The port value should match your application.

Some other values were tweaked as well.

## _Preparing to Deploy_

We're almost there! Before we can deploy our new app, we need to setup a few things in our Fly account first. Namely, we want to provide the needed secrets and we need a database!

### _Setting our Secrets on Fly_

Elixir has a mix task that can generate a new Phoenix key base secret. Let's use that.

```bash
mix phx.gen.secret
```

It generates a long string of random text. Let's store that as a secret for our app. When we run this command in our project folder, `flyctl` uses the `fly.toml` file to know which app we are setting the value on.

```
fly secrets set SECRET_KEY_BASE=<GENERATED>
```

### _Creating our Fly Postgres Database_

```cmd
fly postgres create
```
```output
? App name: hello-elixir-db
Automatically selected personal organization: Mark Ericksen
? Select region: sea (Seattle, Washington (US))
? Select VM size: shared-cpu-1x - 256
? Volume size (GB): 10
Creating postgres cluster hello-elixir-db in organization personal
Postgres cluster hello-elixir-db created
  Username:    <USER>
  Password:    <PASSWORD>
  Hostname:    hello-elixir-db.internal
  Proxy Port:  5432
  PG Port: 5433
Save your credentials in a secure place, you won't be able to see them again!

Monitoring Deployment

2 desired, 2 placed, 2 healthy, 0 unhealthy [health checks: 6 total, 6 passing]
--> v0 deployed successfully

Connect to postgres
Any app within the personal organization can connect to postgres using the above credentials and the hostname "hello-elixir-db.internal."
For example: postgres://<USER>:<PASSWORD>@hello-elixir-db.internal:5432

See the postgres docs for more information on next steps, managing postgres, connecting from outside fly:  https://fly.io/docs/reference/postgres/
```

We can take the defaults which select the lowest values for CPU, size, etc. This is perfect for getting started.

### _Attach our App to the Database_

We use `flyctl` to attach our app to the database which also sets our needed `DATABASE_URL` ENV value.

```cmd
fly postgres attach --postgres-app hello-elixir-db
```
```output
Postgres cluster hello-elixir-db is now attached to fly-elixir
The following secret was added to fly-elixir:
  DATABASE_URL=postgres://<NEW_USER>:<NEW_PASSWORD>@hello-elixir-db.internal:5432/fly_elixir?sslmode=disable
```

We can see the secrets that Fly is using for our app like this.

```cmd
fly secrets list
```
```output
NAME            DIGEST                           DATE
DATABASE_URL    830d8769ff33cba6c8b29d1cd6a6fbac 1m10s ago
SECRET_KEY_BASE 84c992ac7ef334c21f2aaecd41c43666 9m20s ago
```

Looks like we're ready to deploy!

## _Deploying to Fly_

To deploy your app, just run just run:

```cmd
fly deploy
```

First, `flyctl` builds our Dockerfile and pushes it to a Fly container registry.

This will lookup our `fly.toml` file, and get the app name `fly-elixir` from there. Then `flyctl` will start the process of deploying our application to the Fly platform. Flyctl returns you to the command line when it's done.

## _Viewing the Deployed App_

Now that the application has been deployed, let's find out more about its deployment. The command `fly status` will give you all the essential details.

```cmd
fly status
```
```output
App
  Name     = fly-elixir
  Owner    = personal
  Version  = 3
  Status   = running
  Hostname = fly-elixir.fly.dev

Deployment Status
  ID          = 9762642f-baa4-e4df-c683-13f2ce26a6bc
  Version     = v3
  Status      = successful
  Description = Deployment completed successfully
  Instances   = 1 desired, 1 placed, 1 healthy, 0 unhealthy

Instances
ID       PROCESS VERSION REGION DESIRED STATUS  HEALTH CHECKS      RESTARTS CREATED
f617e72a app     3       sea    run     running 1 total, 1 passing 0        1m34s ago
```

## _Connecting to the App_

The quickest way to browse your newly deployed application is with the `fly open` command.

```cmd
fly open
```
```output
Opening https://fly-elixir.fly.dev/
```

Your browser will be sent to the displayed URL. Fly will auto-upgrade this URL to a HTTPS secured URL.

## _Arrived at Destination_

You have successfully built, deployed, and connected to your first Elixir application on Fly. Check out the following bonus sections to go further!

## _Bonus Sections_

With your application up and running, there are some additional things you can do to go further. Using some `flyctl` commands, we can easily do some powerful things with our application.

These bonus tips cover:

- Getting an IEx shell into your running node. This helps you manage and work with your running system.
- Clustering multiple Elixir nodes together. Say "Hello!" to the power of Distributed Computing!
- Scaling your application out to more machines and even distant regions (with or without clustering).

### _What is the IP Address?_

If you want to know what IP addresses the app is using, try `fly ips list`:

```cmd
fly ips list
```
```output
TYPE ADDRESS                              CREATED AT
v4   213.188.199.124                      24m5s ago
v6   2a09:8280:1:ce56:c80f:5071:6e94:6688 24m5s ago
```

### _Getting an IEx Shell into a Running Node_

As mentioned before, Elixir supports getting a IEx shell into a running production node. How cool is that? We already took the steps to configure `rel/env.sh.eex`, so this step should be pretty easy.

There are a couple prerequisites, we first need to establish an [SSH Shell](https://fly.io/docs/flyctl/ssh/) to our machine on Fly.

This step sets up a root certificate for your account and then issues a certificate.

```
fly ssh establish
fly ssh issue --agent
```

With SSH configured, let's open a console.

```cmd
fly ssh console
```
```output
Connecting to hello_elixir.internal... complete
/ #
```

If all went smoothly, you have a shell! Let's launch our remote IEx shell.

```cmd
app/bin/hello_elixir remote
```
```output
Erlang/OTP 24 [erts-12.1.5] [source] [64-bit] [smp:1:1] [ds:1:1:10] [async-threads:1] [jit]

Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(hello_elixir@fdaa:0:1da8:a7b:ac4:b204:7e29:2)1>
```

Awesome! A running IEx shell into our node. You can safely disconnect it using CTRL+C, CTRL+C.

## _Clustering Your Application_

Elixir and the BEAM have the incredible ability to be clustered together and pass messages seamlessly between nodes. Fly makes clustering easy! This extra (and totally optional) portion of the guide walks you through clustering your Elixir application.

There are 2 parts to getting clustering quickly setup on Fly.

- Installing and using `libcluster`
- Scaling our application to multiple VMs

#### _Adding `libcluster`_

The widely adopted library [libcluster](https://github.com/bitwalker/libcluster) helps here.

Libcluster supports multiple strategies for finding and connecting with other nodes. The strategy we'll use is `DNSPoll` which was added in version 3.2.2 of `libcluster`, so make sure you're using that version or newer.

After installing `libcluster`, add it to the application like this:

```elixir
defmodule HelloElixir.Application do
  use Application

  def start(_type, _args) do
    topologies = Application.get_env(:libcluster, :topologies) || []

    children = [
      # ...
      # setup for clustering
      {Cluster.Supervisor, [topologies, [name: HelloElixir.ClusterSupervisor]]}
    ]

    # ...
  end

  # ...
end
```

Our next step is to add the `topologies` configuration to the file `config/runtime.exs`.

```elixir
  app_name =
    System.get_env("FLY_APP_NAME") ||
      raise "FLY_APP_NAME not available"

  config :libcluster,
    debug: true,
    topologies: [
      fly6pn: [
        strategy: Cluster.Strategy.DNSPoll,
        config: [
          polling_interval: 5_000,
          query: "#{app_name}.internal",
          node_basename: app_name
        ]
      ]
    ]
```

**REMEMBER:** Deploy your updated app so the clustering code is available, with `fly deploy`.

This configures `libcluster` to use the `DNSPoll` strategy and look for other deployed apps using the `$FLY_APP_NAME` on the `.internal` private network.

This assumes that your `rel/env.sh.eex` file is configured to name your Elixir node using the `$FLY_APP_NAME`. We did this earlier
when setting up the Elixir console access.

Before this app can be clustered, we need more than one VM. We'll do that next!

#### _Running Multiple VMs_

There are two ways to run multiple VMs.

1. Scale our application to have multiple VMs in one region.
2. Add an VM to another region (multiple regions).

Both approaches are valid and our Elixir application doesn't change at all for the approach you choose!

Let's first start with a baseline of our single deployment.

```cmd
fly status
```
```output
...
VMs
ID       VERSION REGION DESIRED STATUS  HEALTH CHECKS      RESTARTS CREATED
f9014bf7 26      sea    run     running 1 total, 1 passing 0        1h8m ago
```

#### _Scaling in a Single Region_

Let's scale up to 2 VMs in our current region.

```cmd
fly scale count 2
```
```output
Count changed to 2
```

Checking on the status we can see what happened.

```cmd
fly status
```
```output
...
VMs
ID       VERSION REGION DESIRED STATUS  HEALTH CHECKS      RESTARTS CREATED
eb4119d3 27      sea    run     running 1 total, 1 passing 0        39s ago
f9014bf7 27      sea    run     running 1 total, 1 passing 0        1h13m ago
```

We now have two VMs in the same region! That was easy.

Let's make sure they are clustered together. We can check the logs:

```cmd
fly logs
```
```output
...
app[eb4119d3] sea [info] 21:50:21.924 [info] [libcluster:fly6pn] connected to :"fly-elixir@fdaa:0:1da8:a7b:ac2:f901:4bf7:2"
...
```

But that's not as rewarding as seeing it from inside a node. From an IEx shell, we can ask the node we're connected to, what other nodes it can see.

```
fly ssh console
/app/bin/hello_elixir remote
```

```elixir
iex(fly-elixir@fdaa:0:1da8:a7b:ac2:f901:4bf7:2)1> Node.list
[:"fly-elixir@fdaa:0:1da8:a7b:ac4:eb41:19d3:2"]
```

I included the IEx prompt because it shows the IP address of the node I'm connected to. Then getting the `Node.list` returns the other node. Our two VMs are connected and clustered!

#### _Scaling to Multiple Regions_

Fly makes it super easy to run VMs of your applications physically closer to your users. Through the magic of DNS, they will be directed to their nearest region of your application. You can read about [regions](/docs/reference/regions/#welcome-message) here and see the list of regions to choose from.

Starting back from our baseline of a single VM running in `sea` which is Seattle, Washington (US), I'll add the region `ewr` which is Parsippany, NJ (US). This puts an VM on both coasts of the US.

```cmd
fly regions add ewr
```
```output
Region Pool:
ewr
sea
Backup Region:
iad
lax
sjc
vin
```

Looking at the status right now shows that we're only in 1 region because our count is set to 1.

```cmd
fly status
```
```output
...
VMs
ID       VERSION REGION DESIRED STATUS  HEALTH CHECKS      RESTARTS CREATED
cdf6c422 29      sea    run     running 1 total, 1 passing 0        58s ago
```

Let's add a 2nd VM and see it deploy to `ewr`.

```cmd
fly scale count 2
```
```output
Count changed to 2
```

Now our status shows we have two VMs spread across 2 regions!

```cmd
fly status
```
```output
...
VMs
ID       VERSION REGION DESIRED STATUS  HEALTH CHECKS      RESTARTS CREATED
0a8e6666 30      ewr    run     running 1 total, 1 passing 0        16s ago
cdf6c422 30      sea    run     running 1 total, 1 passing 0        6m47s ago
```

Let's ensure they are clustered together.

```
fly ssh console
/app/bin/hello_elixir remote
```

```elixir
iex(fly-elixir@fdaa:0:1da8:a7b:ac2:cdf6:c422:2)1> Node.list
[:"fly-elixir@fdaa:0:1da8:a7b:ab2:a8e:6666:2"]
```

We have two VMs of our application deployed to the West and East coasts of the North American continent and they are clustered together! Our users will automatically be directed to the server nearest them. That is so cool!

## Troubleshooting

Some problems are harder to diagnose because they deal with [Elixir releases](https://hexdocs.pm/mix/master/Mix.Tasks.Release.html) or Docker build problems. Typically, you don't run the application that way locally, so you only encounter those problems when it's time to deploy.

Here are a few tips to help diagnose and identify problems.

- Run `mix release` locally on your project.
- Build the Dockerfile locally to verify it builds correctly. `docker build .`
- Check the `:prod` config in `config/runtime.exs`, which is not used locally. Carefully review it.
- Run `fly logs` to check server logs.
