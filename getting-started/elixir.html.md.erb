---
title: "Deploy an Elixir Phoenix Application"
layout: docs
sitemap: false
nav: firecracker
---

<%= partial "partials/intro", locals: { runtime: "Elixir Phoenix", database: true } %>

We'll be using the standard web application generated by the Elixir [Phoenix Framework](https://www.phoenixframework.org/). This guide assumes you're working with **Phoenix 1.6.3** or later which include a code generator to simplify deployment.

## Generate the app and deploy with Postgres

If you just want to see how Fly deployment works, follow these steps.

First, [install flyctl](https://fly.io/docs/getting-started/installing-flyctl/), your Fly app command center, and [sign up to Fly](http://localhost:4567/docs/getting-started/log-in-to-fly/#first-time-or-no-fly-account-sign-up-for-fly) if you haven't already.

Now let's generate a shiny, new Phoenix app.

```cmd
mix phx.new hello_elixir
```
```output
* creating fresh/config/config.exs
* creating fresh/config/dev.exs
* creating fresh/config/prod.exs
...
```
<%= partial "partials/launch_with_postgres", locals: { detected: "Phoenix", app_name: "hello_elixir" } %>

## _Getting an IEx Shell into a Running Node_

Elixir supports getting a IEx shell into a running production node. How cool is that? This requires a bit more setup.

`rel/env.sh.eex` is run when your app boots. Create or update it with the following contents, and run `fly deploy`.

```
ip=$(grep fly-local-6pn /etc/hosts | cut -f 1)
export RELEASE_DISTRIBUTION=name
export RELEASE_NODE=$FLY_APP_NAME@$ip
```

Now we need to [login with SSH](https://fly.io/docs/flyctl/ssh/) to our application VM. First we need to run do two, one-time
setup tasks for preparing secure access to Fly applications. Follow the instructions.

```
fly ssh establish
fly ssh issue --agent
```

With SSH configured, let's open a console.

```cmd
fly ssh console
```
```output
Connecting to hello_elixir.internal... complete
/ #
```

If all went smoothly, you have a shell! Let's launch our remote IEx shell.

```cmd
app/bin/hello_elixir remote
```
```output
Erlang/OTP 24 [erts-12.1.5] [source] [64-bit] [smp:1:1] [ds:1:1:10] [async-threads:1] [jit]

Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(hello_elixir@fdaa:0:1da8:a7b:ac4:b204:7e29:2)1>
```

Awesome! A running IEx shell into our node. You can safely disconnect it using CTRL+C, CTRL+C.

## _Clustering Your Application_

Elixir and the BEAM have the incredible ability to be clustered together and pass messages seamlessly between nodes. Fly makes clustering easy! This extra (and totally optional) portion of the guide walks you through clustering your Elixir application.

There are 2 parts to getting clustering quickly setup on Fly.

- Installing and using `libcluster`
- Scaling our application to multiple VMs

#### _Adding `libcluster`_

The widely adopted library [libcluster](https://github.com/bitwalker/libcluster) helps here.

Libcluster supports multiple strategies for finding and connecting with other nodes. The strategy we'll use is `DNSPoll` which was added in version 3.2.2 of `libcluster`, so make sure you're using that version or newer.

After installing `libcluster`, add it to the application like this:

```elixir
defmodule HelloElixir.Application do
  use Application

  def start(_type, _args) do
    topologies = Application.get_env(:libcluster, :topologies) || []

    children = [
      # ...
      # setup for clustering
      {Cluster.Supervisor, [topologies, [name: HelloElixir.ClusterSupervisor]]}
    ]

    # ...
  end

  # ...
end
```

Our next step is to add the `topologies` configuration to the file `config/runtime.exs`.

```elixir
  app_name =
    System.get_env("FLY_APP_NAME") ||
      raise "FLY_APP_NAME not available"

  config :libcluster,
    debug: true,
    topologies: [
      fly6pn: [
        strategy: Cluster.Strategy.DNSPoll,
        config: [
          polling_interval: 5_000,
          query: "#{app_name}.internal",
          node_basename: app_name
        ]
      ]
    ]
```

**REMEMBER:** Deploy your updated app so the clustering code is available, with `fly deploy`.

This configures `libcluster` to use the `DNSPoll` strategy and look for other deployed apps using the `$FLY_APP_NAME` on the `.internal` private network.

This assumes that your `rel/env.sh.eex` file is configured to name your Elixir node using the `$FLY_APP_NAME`. We did this earlier
when setting up the Elixir console access.

Before this app can be clustered, we need more than one VM. We'll do that next!

#### _Running Multiple VMs_

There are two ways to run multiple VMs.

1. Scale our application to have multiple VMs in one region.
2. Add an VM to another region (multiple regions).

Both approaches are valid and our Elixir application doesn't change at all for the approach you choose!

Let's first start with a baseline of our single deployment.

```cmd
fly status
```
```output
...
VMs
ID       VERSION REGION DESIRED STATUS  HEALTH CHECKS      RESTARTS CREATED
f9014bf7 26      sea    run     running 1 total, 1 passing 0        1h8m ago
```

#### _Scaling in a Single Region_

Let's scale up to 2 VMs in our current region.

```cmd
fly scale count 2
```
```output
Count changed to 2
```

Checking on the status we can see what happened.

```cmd
fly status
```
```output
...
VMs
ID       VERSION REGION DESIRED STATUS  HEALTH CHECKS      RESTARTS CREATED
eb4119d3 27      sea    run     running 1 total, 1 passing 0        39s ago
f9014bf7 27      sea    run     running 1 total, 1 passing 0        1h13m ago
```

We now have two VMs in the same region! That was easy.

Let's make sure they are clustered together. We can check the logs:

```cmd
fly logs
```
```output
...
app[eb4119d3] sea [info] 21:50:21.924 [info] [libcluster:fly6pn] connected to :"fly-elixir@fdaa:0:1da8:a7b:ac2:f901:4bf7:2"
...
```

But that's not as rewarding as seeing it from inside a node. From an IEx shell, we can ask the node we're connected to, what other nodes it can see.

```
fly ssh console
/app/bin/hello_elixir remote
```

```elixir
iex(fly-elixir@fdaa:0:1da8:a7b:ac2:f901:4bf7:2)1> Node.list
[:"fly-elixir@fdaa:0:1da8:a7b:ac4:eb41:19d3:2"]
```

I included the IEx prompt because it shows the IP address of the node I'm connected to. Then getting the `Node.list` returns the other node. Our two VMs are connected and clustered!

#### _Scaling to Multiple Regions_

Fly makes it super easy to run VMs of your applications physically closer to your users. Through the magic of DNS, they will be directed to their nearest region of your application. You can read about [regions](/docs/reference/regions/#welcome-message) here and see the list of regions to choose from.

Starting back from our baseline of a single VM running in `sea` which is Seattle, Washington (US), I'll add the region `ewr` which is Parsippany, NJ (US). This puts an VM on both coasts of the US.

```cmd
fly regions add ewr
```
```output
Region Pool:
ewr
sea
Backup Region:
iad
lax
sjc
vin
```

Looking at the status right now shows that we're only in 1 region because our count is set to 1.

```cmd
fly status
```
```output
...
VMs
ID       VERSION REGION DESIRED STATUS  HEALTH CHECKS      RESTARTS CREATED
cdf6c422 29      sea    run     running 1 total, 1 passing 0        58s ago
```

Let's add a 2nd VM and see it deploy to `ewr`.

```cmd
fly scale count 2
```
```output
Count changed to 2
```

Now our status shows we have two VMs spread across 2 regions!

```cmd
fly status
```
```output
...
VMs
ID       VERSION REGION DESIRED STATUS  HEALTH CHECKS      RESTARTS CREATED
0a8e6666 30      ewr    run     running 1 total, 1 passing 0        16s ago
cdf6c422 30      sea    run     running 1 total, 1 passing 0        6m47s ago
```

Let's ensure they are clustered together.

```
fly ssh console
/app/bin/hello_elixir remote
```

```elixir
iex(fly-elixir@fdaa:0:1da8:a7b:ac2:cdf6:c422:2)1> Node.list
[:"fly-elixir@fdaa:0:1da8:a7b:ab2:a8e:6666:2"]
```

We have two VMs of our application deployed to the West and East coasts of the North American continent and they are clustered together! Our users will automatically be directed to the server nearest them. That is so cool!

## Troubleshooting

Some problems are harder to diagnose because they deal with [Elixir releases](https://hexdocs.pm/mix/master/Mix.Tasks.Release.html) or Docker build problems. Typically, you don't run the application that way locally, so you only encounter those problems when it's time to deploy.

Here are a few tips to help diagnose and identify problems.

- Run `mix release` locally on your project.
- Build the Dockerfile locally to verify it builds correctly. `docker build .`
- Check the `:prod` config in `config/runtime.exs`, which is not used locally. Carefully review it.
- Run `fly logs` to check server logs.
