---
title: "Deploy an Elixir Phoenix Application"
layout: docs
sitemap: false
nav: firecracker
---

<%= partial "partials/intro", locals: { runtime: "Elixir Phoenix", database: true, link: "https://www.phoenixframework.org/" } %>

**This guide is for apps running on Phoenix 1.6.3 or later, where deployment is streamlined significantly.
If you're on an earlier version and can't upgrade, check out our [previous deployment guide](/docs/getting-started/legacy_elixir).**

We'll be using the standard web application generated by the Elixir [Phoenix Framework](https://www.phoenixframework.org/).

## _Generate the app and deploy with Postgres_

If you just want to see how Fly deployment works, follow these steps.

First, [install flyctl](/docs/getting-started/installing-flyctl/), your Fly app command center, and [sign up to Fly](/docs/getting-started/log-in-to-fly/#first-time-or-no-fly-account-sign-up-for-fly) if you haven't already.

Now let's generate a shiny, new Phoenix app.

```cmd
mix phx.new hello_elixir
```
```output
* creating fresh/config/config.exs
* creating fresh/config/dev.exs
* creating fresh/config/prod.exs
...
```
<%= partial "partials/launch_with_postgres", locals: { detected: "Phoenix", app_name: "hello_elixir" } %>

## _IEx Shell into Your Running App_

Elixir supports getting a IEx shell into your running app. How cool is that?

To do this, we will [login with SSH](/docs/flyctl/ssh/) to our
application VM. There are a couple one-time setup tasks for using SSH. Follow the instructions.

```
fly ssh establish
fly ssh issue --agent
```

With SSH configured, let's open a console.

```cmd
fly ssh console
```
```output
Connecting to hello_elixir.internal... complete
/ #
```

If all went smoothly, you have a shell to the machine!

Now we can start the IEx shell to our application. The command is named for your application. For this example it is:

```cmd
/app/bin/hello_elixir remote
```

This starts up an IEx shell to our application!

This Elixir command shows the name of our application node.

```elixir
Node.self()
#=> :hello_elixir@0d85bf00
```

With another quick update we can prepare our application for clustering by naming our nodes differently. That's next!

## _Naming Your Elixir Node_

In your Elixir application, create or update the file `rel/env.sh.eex` and paste this in.

```shell
ip=$(grep fly-local-6pn /etc/hosts | cut -f 1)
export RELEASE_DISTRIBUTION=name
export RELEASE_NODE=$FLY_APP_NAME@$ip
```

This names our Elixir node using the Fly application name and the internal IPv6 address. Make sure to deploy after making this change!

```cmd
fly deploy
```

Now when you SSH in and see the node name, it will look something like this:

```elixir
Node.self()
#=> :"hello_elixir@fdaa:0:1da8:a7b:87:1313:f12:2"
```

Nice! Our application is ready for clustering!

## _Clustering Your Application_

Elixir and the BEAM have the incredible ability to be clustered together and
processes can pass messages seamlessly to each other between nodes. Fly makes
clustering easy! This extra (and totally optional) portion of the guide walks
you through clustering your Elixir application.

There are 2 parts to getting clustering quickly setup on Fly.

- Installing and using `libcluster`
- Scaling our application to multiple VMs

#### _Adding `libcluster`_

The widely adopted library [libcluster](https://github.com/bitwalker/libcluster) helps here.

Libcluster supports multiple strategies for finding and connecting with other nodes. The strategy we'll use is `DNSPoll` which was added in version 3.2.2 of `libcluster`, so make sure you're using that version or newer.

After installing `libcluster`, add it to the application like this:

```elixir
defmodule HelloElixir.Application do
  use Application

  def start(_type, _args) do
    topologies = Application.get_env(:libcluster, :topologies) || []

    children = [
      # ...
      # setup for clustering
      {Cluster.Supervisor, [topologies, [name: HelloElixir.ClusterSupervisor]]}
    ]

    # ...
  end

  # ...
end
```

Our next step is to add the `topologies` configuration to the file `config/runtime.exs`.

```elixir
  app_name =
    System.get_env("FLY_APP_NAME") ||
      raise "FLY_APP_NAME not available"

  config :libcluster,
    debug: true,
    topologies: [
      fly6pn: [
        strategy: Cluster.Strategy.DNSPoll,
        config: [
          polling_interval: 5_000,
          query: "#{app_name}.internal",
          node_basename: app_name
        ]
      ]
    ]
```

**REMEMBER:** Deploy your updated app so the clustering code is available, with `fly deploy`.

This configures `libcluster` to use the `DNSPoll` strategy and look for other deployed apps using the same `$FLY_APP_NAME` on the `.internal` private network.

This assumes that your `rel/env.sh.eex` file is configured to name your Elixir node using the `$FLY_APP_NAME`. We did this earlier in the "Naming Your Elixir Node" section.

Before this app can be clustered, we need more than one VM. We'll do that next!

#### _Running Multiple VMs_

There are two ways to run multiple VMs.

1. Scale our application to have multiple VMs in one region.
2. Add an VM to another region (multiple regions).

Both approaches are valid and our Elixir application doesn't change at all for the approach you choose!

Let's first start with a baseline of our single deployment.

```cmd
fly status
```
```output
...
VMs
ID       VERSION REGION DESIRED STATUS  HEALTH CHECKS      RESTARTS CREATED
f9014bf7 26      sea    run     running 1 total, 1 passing 0        1h8m ago
```

#### _Scaling in a Single Region_

Let's scale up to 2 VMs in our current region.

```cmd
fly scale count 2
```
```output
Count changed to 2
```

Checking on the status we can see what happened.

```cmd
fly status
```
```output
...
VMs
ID       VERSION REGION DESIRED STATUS  HEALTH CHECKS      RESTARTS CREATED
eb4119d3 27      sea    run     running 1 total, 1 passing 0        39s ago
f9014bf7 27      sea    run     running 1 total, 1 passing 0        1h13m ago
```

We now have two VMs in the same region! That was easy.

Let's make sure they are clustered together. We can check the logs:

```cmd
fly logs
```
```output
...
app[eb4119d3] sea [info] 21:50:21.924 [info] [libcluster:fly6pn] connected to :"fly-elixir@fdaa:0:1da8:a7b:ac2:f901:4bf7:2"
...
```

But that's not as rewarding as seeing it from inside a node. From an IEx shell, we can ask the node we're connected to, what other nodes it can see.

```
fly ssh console
/app/bin/hello_elixir remote
```

```elixir
iex(fly-elixir@fdaa:0:1da8:a7b:ac2:f901:4bf7:2)1> Node.list
[:"fly-elixir@fdaa:0:1da8:a7b:ac4:eb41:19d3:2"]
```

I included the IEx prompt because it shows the IP address of the node I'm connected to. Then getting the `Node.list` returns the other node. Our two VMs are connected and clustered!

#### _Scaling to Multiple Regions_

Fly makes it super easy to run VMs of your applications physically closer to your users. Through the magic of DNS, they will be directed to their nearest region of your application. You can read about [regions](/docs/reference/regions/#welcome-message) here and see the list of regions to choose from.

Starting back from our baseline of a single VM running in `sea` which is Seattle, Washington (US), I'll add the region `ewr` which is Parsippany, NJ (US). This puts an VM on both coasts of the US.

```cmd
fly regions add ewr
```
```output
Region Pool:
ewr
sea
Backup Region:
iad
lax
sjc
vin
```

Looking at the status right now shows that we're only in 1 region because our count is set to 1.

```cmd
fly status
```
```output
...
VMs
ID       VERSION REGION DESIRED STATUS  HEALTH CHECKS      RESTARTS CREATED
cdf6c422 29      sea    run     running 1 total, 1 passing 0        58s ago
```

Let's add a 2nd VM and see it deploy to `ewr`.

```cmd
fly scale count 2
```
```output
Count changed to 2
```

Now our status shows we have two VMs spread across 2 regions!

```cmd
fly status
```
```output
...
VMs
ID       VERSION REGION DESIRED STATUS  HEALTH CHECKS      RESTARTS CREATED
0a8e6666 30      ewr    run     running 1 total, 1 passing 0        16s ago
cdf6c422 30      sea    run     running 1 total, 1 passing 0        6m47s ago
```

Let's ensure they are clustered together.

```
fly ssh console
/app/bin/hello_elixir remote
```

```elixir
iex(fly-elixir@fdaa:0:1da8:a7b:ac2:cdf6:c422:2)1> Node.list
[:"fly-elixir@fdaa:0:1da8:a7b:ab2:a8e:6666:2"]
```

We have two VMs of our application deployed to the West and East coasts of the North American continent and they are clustered together! Our users will automatically be directed to the server nearest them. That is so cool!

## Troubleshooting

Some problems are harder to diagnose because they deal with [Elixir releases](https://hexdocs.pm/mix/master/Mix.Tasks.Release.html) or Docker build problems. Typically, you don't run the application that way locally, so you only encounter those problems when it's time to deploy.

Here are a few tips to help diagnose and identify problems.

- Run `mix release` locally on your project.
- Build the Dockerfile locally to verify it builds correctly. `docker build .`
- Check the `:prod` config in `config/runtime.exs`, which is not used locally. Carefully review it.
- Run `fly logs` to check server logs.
