---
title: "Run a Meteor App"
layout: framework_docs
redirect_from:
 - /docs/languages-and-frameworks/meteor/
 - /docs/getting-started/meteor/
objective: Meteor is a full-stack JavaScript framework for building modern web and mobile applications.
order: 3
---

<% app_name = "hello-meteor" %>
<%= partial "partials/intro", locals: { runtime: "Meteor", link: "https://meteor.com" } %>

<div class="callout">
This guide is intended for users of Meteor 3. If you're using Meteor 2 and want to migrate, please see the <a href="https://v3-migration-docs.meteor.com/">Meteor 3.0 migration guide</a>.
</div>

Meteor is a full-stack JavaScript framework for building modern web and mobile applications. You get realtime features for free, built-in accounts, TypeScript support, and a powerful CLI tool for creating and managing your app.

We'll start off by installing Meteor:

```cmd
npx meteor@latest
```
```output
=> Arch: os.osx.arm64
=> Meteor Release: 3.0
Downloading |█████████████████████████████████░░░░░░░| 82%
```

## _Generate the Meteor app_

We'll assume you have NodeJS installed already. Meteor 3 requires NodeJS v20 or higher. We'll be using a skeleton web application generated by [Meteor](https://meteor.com/). This is a bare-bones app that does not need a MongoDB database.

Let's create the new project by running `meteor create`. We'll choose a "minimal " skeleton, which is a good choice for a new project and to get up and running quickly.

```cmd
meteor create hello-meteor --minimal
```
```output
Created a new Meteor app in 'hello-meteor'.

To run your new app:
  cd hello-meteor
  meteor

If you are new to Meteor, try some of the learning resources here:
  https://www.meteor.com/tutorials

When you’re ready to deploy and host your new Meteor application, check out
Cloud:
  https://www.meteor.com/cloud
```

## _Building the Application_

Building a Meteor app happens in two stages, both of which are executed when the command `npm run build` is run.

Firstly, Vite undertakes the creation of an optimized production build that encompasses your server code, browser code, and, if applicable, your service worker. Pre-rendering is carried out during this stage if deemed necessary.

Secondly, an adapter is employed to fine-tune this production build to align with your specific target environment.

## _Preview your Application_

Once the build process is complete, you can preview your production build locally by executing the command `meteor run`.

```cmd
meteor run
```
```output
[[[[[ ~/hello-meteor ]]]]]

=> Started proxy.
=> Started HMR server.
=> Started MongoDB.
=> Started your app.

=> App running at: http://localhost:3000/
```

## _Install flyctl and Login_

We are ready to start working with Fly.io, and that means we need `flyctl`, our CLI app for managing apps on Fly.io. If you've already installed it, carry on. If not, hop over to [our installation guide](/docs/flyctl/install/). Once that's installed you'll want to [log in to Fly.io](/docs/getting-started/sign-up-sign-in/).

## _Deploy the app on Fly.io_

Each Fly App needs a `fly.toml` file to tell the system how we'd like to deploy it.
That file can be automatically generated with  `fly launch`. This command will also generate a Dockerfile for deployment.

```cmd
fly launch
```
```output
Scanning source code
Detected a Meteor app
Creating app in /Demo/hello-meteor
We're about to launch your Meteor app on Fly.io. Here's what you're getting:

Organization: Demo                       (fly launch defaults to the personal org)  
Name:         hello-meteor               (generated)
Region:       Johannesburg, South Africa (this is the fastest region for you)
App Machines: shared-cpu-1x, 1GB RAM     (most apps need about 1GB of RAM)
Postgres:     <none>                     (not requested)
Redis:        <none>                     (not requested)
Tigris:       <none>                     (not requested)

? Do you want to tweak these settings before proceeding? No
Created app 'hello-meteor' in organization 'demo'
Admin URL: https://fly.io/apps/hello-meteor
Hostname: hello-meteor.fly.dev
installing: npm install @flydotio/dockerfile@latest --save-dev

added 33 packages, and audited 143 packages in 4s

32 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
     create  Dockerfile
Wrote config file fly.toml
Validating /Demo/hello-meteor/fly.toml
✓ Configuration is valid
==> Building image
Remote builder fly-builder-frosty-night-3947 ready
==> Building image with Docker
...

Watch your deployment at https://fly.io/apps/hello-meteor/monitoring

Provisioning ips for hello-meteor
  Dedicated ipv6: 2a09:8280:1::3c:c2d4:0
  Shared ipv4: 66.241.124.224
  Add a dedicated ipv4 with: fly ips allocate-v4

This deployment will:
 * create 2 "app" machines

No machines in group app, launching a new machine

Creating a second machine to increase service availability
Finished launching new machines
-------
NOTE: The machines for [app] have services with 'auto_stop_machines = true' that will be stopped when idling

-------
Checking DNS configuration for mhello-meteor.fly.dev

Visit your newly deployed app at https://hello-meteor.fly.dev/
...
```

## _Inside `fly.toml`_

The `fly.toml` file now contains a default configuration for deploying your app. In the process of creating that file, `flyctl` has also created a Fly.io application slot of the same name, "hello-meteor". If we look at the `fly.toml` configuration file we can see the name in there:

```toml
app = "hello-meteor"
primary_region = "ord"

[env]
  PORT = "3000"
  ROOT_URL = "https://hello-meteor.fly.dev/"

[http_service]
  internal_port = 3000
  force_https = true
  auto_stop_machines = true
  auto_start_machines = true
  min_machines_running = 0
  processes = ["app"]
...
```

The `flyctl` command will always refer to this file in the current directory if it exists, specifically for the `app` name/value at the start. That name will be used to identify the application to the Fly.io platform.

The rest of the file contains settings to be applied to the application when it deploys.

## Deploying to Fly.io

We are now ready to deploy our containerized app to Fly.io:

```cmd
fly deploy
```

This will get the app name `hello-meteor` from our `fly.toml` and start the process of deploying our application to Fly.io using the Dockerfile. `fly` will return you to the command line when it's done.

## _Viewing the Deployed App_

If you want to find out more about the deployment. The command `fly status` will give you all the essential details.

```cmd
fly status
```
```output
App
  Name     = hello-meteor
  Owner    = personal
  Hostname = hello-meteor.fly.dev
  Image    = hello-meteor:deployment-01J2S3S8A9TDR1D2AYZSYJWTHH

Machines
PROCESS	ID            	VERSION	REGION	STATE  	ROLE	CHECKS	LAST UPDATED
app    	3287154db00658	1      	jnb   	started	    	      	2024-07-14T17:26:16Z
app    	4d890d17a6d768	1      	jnb   	stopped	    	      	2024-07-14T17:23:03Z
```

## _Connecting to the App_

The quickest way to browse your newly deployed application is with the `flyctl apps open` command.

```cmd
flyctl apps open
```
```output
Opening https://hello-meteor.fly.dev/
```

Your browser will be sent to the displayed URL.

## _Bonus Points_

If you want to know what IP addresses the app is using, try `fly ips list`:

```cmd
fly ips list
```

```out
VERSION IP                      TYPE            REGION  CREATED AT 
v6      2a09:8280:1::69:37fd    public          global  18m55s ago
v4      66.241.125.223          public (shared)
```

## A word on Session Affinity (AKA 'Sticky Sessions')

Sticky sessions are a feature of a load balancer that ensures that all requests from a client are routed to the same server. This can be important for Meteor applications depending on the client/server architecture of your app, as it ensures that the client is always connected to the same server, and that any changes made to the server are reflected in the client.

To achieve this on Fly.io, you can run your app with a maximum of one Machine per region. The [Fly Proxy](docs/reference/fly-proxy/) will take care of load balancing clients to the Machine closest to them, and will ensure that all requests from a client are routed to the same Machine.

Now, when your app starts getting popular and receiving traffic from all over the world, you can [scale out](/docs/launch/scale-count/#balance-machines-between-regions-with-max-per-region) to multiple regions and balance Machines per region with the `--max-per-region` flag set to `1`.

```cmd
fly scale count 3 --max-per-region 1
```

## Arrived at Destination

You have successfully built, deployed, and connected to your first Meteor application on Fly.io.
