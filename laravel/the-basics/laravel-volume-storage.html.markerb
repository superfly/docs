---
title: "Persisting the Storage Folder"
layout: framework_docs
objective: Mount a volume to a re-initialized storage folder 
order: 7
---

The [storage folder](https://laravel.com/docs/9.x/filesystem#the-local-driver) by default, holds several "generated" essentials of your Laravel application. It's the default burrow for session, cache, and file data amongst other data generated on your Laravel app. 

However, applications deployed on Fly.io are ephemeral&mdash;meaning data generated on your app during runtime does not persist across redeployments or Machine restarts.

There're many parts to the Laravel storage folder, and in this documentation, we'll tackle two ways of persisting data on these: 

1. [Mount](/docs/laravel/the-basics/laravel-volume-storage/#mounting-a-fly-volume) a Fly Volume to the Laravel storage folder to persist data on it
2. Save data across external Fly Apps: 
    Tigris S3-Compatible Bucket for File Storage, 
    Redis for Cache, Session, and Views


## Mounting a Fly Volume
[Fly Volumes](https://fly.io/docs/volumes/overview/) are local persistent storage that can be mounted on Fly Machines. We can mount a volume to our Laravel app's storage folder to persist data on it throughout restarts and re-deployments.

Doing so  would allow us to "locally" store data on our Laravel Fly App, and in doing so, would allow us to store generated data in one place. A strong caveat however, is that a Fly Volume can only attach to one Machine, and therefore can only be accessed from that specific Machine.  

1.  Make sure you are in your Laravel Fly App's directory

    ```cmd
    cd <laravel-fly-configured-app>
    ```

2.  Then, check the number of machines currently available for your Fly App:

    ```cmd
    fly status
    ```

    In this example today, the app is deployed in the AMS region, and has the [default number of two machines](https://fly.io/docs/reference/app-availability/#two-machines-for-process-groups-with-services) created for it:
    ```cmd

    Machines
    PROCESS ID              VERSION REGION  STATE   ROLE    CHECKS  LAST UPDATED         
    app     5683945bd46448  1       ams     started                 2023-10-03T09:54:04Z
    app     e82d922f010908  1       ams     started                 2023-10-03T09:54:25Z
    ```

    
3.  To mount a volume named `"storage_vol"` to this Fly App, you'll have to create two `"storage_vol"` volumes in the AMS region, [one for each machine](https://fly.io/docs/volumes/overview/#volume-considerations):
    ```cmd
    fly volumes create storage_vol --region ams --count 2 
    ```
    Running the command above should create two separate volumes with the name "storage_vol", in the AMS region for your Laravel Fly App.
   
4.  Next, revise your Laravel Fly App's `fly.toml` file to mount the Volumes above to each machine's storage folder:

    ```
    [mounts]
      source="storage_vol"
      destination="/var/www/html/storage"
    ```

      <div class="callout">
      Mounting a Volume to a folder will initially erase any item the folder contains during the first time the Volume is mounted for the folder.
      <br><br>
      For example, Laravel's storage folder contains subfolders: app, framework, and logs. 
      Mounting a volume to the storage folder erases these directories, and leaves behind a sole item paradoxically named as "lost+found". 
      <br><br>
      But, you wouldn't want to only be left with "lost+found" in your storage folder. You'd want to still have the necessary files and directories in there for successful session, views, caching, and file storage compliance with Laravel's default configuration.
      </div>


5.  To fix the little storage-content-erasure issue as stated in the callout above, please go ahead and make a copy of your storage folder in a "backup" folder. You can name this directory "storage_".

    ```cmd
    cp -r storage storage_
    ```

    You'll later use this folder to copy over its contents to the volumized storage folder.

6.  Next create a [Startup Script](/docs/laravel/the-basics/customizing-deployments/) that will initialize the volumized storage folder's contents.
    ```cmd
    touch .fly/scripts/1_storage_init.sh
    ```

    Start up scripts are run in numeric-alphabetical order. Naming `1\_storage\_init.sh` makes sure it is the first script run. Otherwise, naming the file as `storage_init.sh` alone would've moved the `caches.sh` script above it, and would've executed before storage initialization happened. One of the commands in the `caches.sh` will not have worked properly, due to a lack of properly initialized storage directory.

    <b>On to the content of the Start Up script:</b>

    ```bash
    FOLDER=/var/www/html/storage/app
    if [ ! -d "$FOLDER" ]; then
        echo "$FOLDER is not a directory, copying storage_ content to storage"
        cp -r /var/www/html/storage_/. /var/www/html/storage
        echo "deleting storage_..."
        rm -rf /var/www/html/storage_
    fi
    ```

    So what happened above?
    - The condition statement checks if the app folder does not exist in the volumized storage folder. If it does not exist, it copies over the contents of the storage_ folder to the volumized storage folder.

7. <b>Finally, deploy your Laravel Fly App!</b>
 
    ```cmd
    fly deploy
    ```

<div class="callout">
Fly Volumes do not automatically sync their data with each other. Please remember to create the appropriate data-replication logic if your Fly App will be using more than one volume instance, and if your app requires data available across its Volumes.
</div> 

### **_Possible Errors_**

```output
Error not enough volumes named `<volume_name>` (1) to run `(<n>)` processes
```

The above error can come up after configuring your volume in `fly.toml` and executing `fly deploy`. 

It can mean that there are `<n>` processes configured in your `fly.toml` trying to use the volume!
Take note however, that a Volume can only be used by one at any given time. 

One way to fix this issue is to separate each process into [different Fly.io apps](/docs/app-guides/multiple-processes/#maybe-you-want-multiple-apps-though). Of course, separate application per process might require inter-communication between the applications. 

Fly.io applications can easily communicate with each other over a [private network](/docs/networking/private-networking/). Not only that, but Fly.io also offers the `fly-replay` [response header](/docs/networking/dynamic-request-routing/#the-fly-replay-response-header) which can be used to "redirect" request from one application to another, and return response from the correct application.


## Tigris Bucket for File Storage

The Laravel Filesystem provides integration with Amazon S3's file storage driver. Instead of saving files to the local `storage/app` directory of a Laravel application, the S3 driver can connect and send files over to Amazon S3 compatible service.

Tigris is an S3-compatible storage service built on Fly.io infrastructure,with an added bonus of providing CDN-like behavior with zero configuration needed. So if you have multiple Machines across different regions, you can rest assured for your files to be accessible across these Machines.


1. To start, create a Tigris Bucket:

    ```cli
    fly storage create
    ```
    You'll be asked for a custom name for your bucket, but you can choose to create one with a random name. Afterwards, wait a moment for your bucket to get initialized and receive the details of your bucket:
    ```cli
    Setting the following secrets on <fly-app-name>:
    AWS_ACCESS_KEY_ID: tid_RTur_dGXddWaJaZhBdkIGpZNJyNLDRDHwdUXYmfZifFDHXxCMT
    AWS_ENDPOINT_URL_S3: https://fly.storage.tigris.dev
    AWS_REGION: auto
    AWS_SECRET_ACCESS_KEY: tsec_zpZwGxjPeMXDcBh4SHuHjwOYRxnfiKrrCqCAKizy+7udoTlKs9LGZ5a5AU3+9PENsCJ8N1
    BUCKET_NAME: weathered-cloud-4166
    ```

2. Once you've taken note of these secrets, you can visit this newly created bucket by getting your console link using the `BUCKET_NAME` attribute received from above:

    ```
    fly storage dashboard weathered-cloud-4166
    ```
    Running the above should give you a link to your bucket's console dashboard:
    ```
    Opening https://console.tigris.dev/flyio/signin?org_id=6y84kn089gw5z3gw ...
    ```
    Visiting the link provided will lead you to your Tigris console, where you should see the name of the Bucket you've recently created. Of course, you'll have to be logged in via Fly.io to access this dashboard. 

3. Setup with Laravel

    Since Tigris is S3-compatible, we can simply leverage Laravel's existing S3 storage driver to connect with our Tigris Bucket. 
    Make sure you have the S3 driver installed for your project. After installing the S3 driver, it's only a matter of filling in the blanks with values for the AWS S3 environment variables needed by Laravel's S3 driver. 
    During our creation of the Tigris bucket we received configuration values, which we can update our .env values with, like so: